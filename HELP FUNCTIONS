int		count_tokens(char *g_line)
{
	int i = 0;
	int tokens = 0;
	while (g_line[i])
	{
		if (g_line[i] == '"' || g_line == '<' || g_line == '>')
			tokens++;
		i++;
	}
	return(tokens)
}

char	*handle_infile(char *str)
{
	int i = 0;
	char *t = NULL;
	int j = 0;
	int fd;
	while (str[i] == ' ' || str[i] == '\t')
		i++;
	while (str[i] != ' ' && str[i] != '\t')
	{
		t[j] = str[i];
		j++;
		i++;
	}
	t[j] ='\0';
	return(t);
}

void	opens(char *infile)
{
	int fd = open(infile, O_RDONLY);
	if (!fd)
	{
		//faz qq coisa
	}
}

// int	check_type(char *split)
// {
// 	if (split[0] == '<' || split[0] == '>')
// 		return (OPERATOR);
// 	if (split[0] == '-')
// 		return (FLAG);
// 	if (split[0] == '|')
// 		return (PIPE);
// 	if (strcmp(split, "echo") || strcmp(split, "cd") || strcmp(split, "pwd") \
// 		|| strcmp(split, "export") || strcmp(split, "unset") || \
// 		strcmp(split, "env") || strcmp(split, "exit"))
// 		return (BUILTIN);
// }

// void	parse_split(char **split, t_program	**list)
// {
// 	int			i;
// 	t_program	*node;
// 	t_program	*curr;
// 	i = -1;
// 	while (split[++i])
// 	{
// 		if (check_type(split[i]) == BUILTIN)
// 			program().type = ;
// 		// else
// 		// {
// 		// 	node = malloc(sizeof(t_program));
// 		// 	node->type = check_type(split[i]);
// 		// 	if (node->type == OPERATOR)
// 		// 		align_file(&node);
// 		// 	if (node->type == PROGRAM)
// 		// 		get_flags(&node);
// 		// }
// 	}
// }

char	**quoting(char *split)
{
	char	**quoted_line;

	//adicionar espacos onde for preciso
	quoted_line = ft_split(split, ' ');
	return (quoted_line);
}

void	parse_split(char **quoted_line)
{
	// fill_nodes();
	// execute();
	// if (!check_builtin(quoted_line))
	// {
	// 	printf("Not a builtin\n");
	// }
}
